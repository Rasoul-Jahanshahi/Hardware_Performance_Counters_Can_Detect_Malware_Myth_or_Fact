#include "../include/stdafx.h"


// Thread body
unsigned int __stdcall expire_thread(void*);

// Constructor to initialize the thread attributes
Timer::Timer( unsigned int *expiry_time)
{
	// Thread Properties
	security = NULL;
	stack_size = 512000;
	arglist = (void*)1;
	initflag = CREATE_SUSPENDED;
	thrdaddr = 0;
	
	// Thread affinity
	// Thread Affinity
	DWORD_PTR dwThreadAffinityMask = 0x7F; // Core 3
	DWORD_PTR thread_affinity = 10; // Randomly choose anything but 0

	// Mutex properties
	lpMutexAttributes = 0;
	bInitialOwner = 0;
	lpName = (LPCTSTR)"expiry_mutex";

	// Variables that require atomicity 
	terminate_timer_flag=0;

	// stores the time to run the timer
	this->expiry_time = *expiry_time;
}


// Using the thread attribute spawn a new thread that starts the exipry timers
// Expiry Timer: On expiry of the timer, the process with the application will be terminated
void Timer::setup_timer()
{

	// Creating the Mutex
	mutex = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);

	// Setup the arguments for the sampling thread
	arglist = (void*)this;

	// Spawing a new timer thread
	expiry_timer   = (HANDLE)_beginthreadex(security, stack_size, &expire_thread, arglist, initflag, thrdaddr);
	thread_affinity = SetThreadAffinityMask(expiry_timer, dwThreadAffinityMask);
	if (thread_affinity == 0)
		std::cout << "Could not set the expiry timer thread affinity with error code" << GetLastError() << std::endl;


	return;
}

bool Timer::release_timer(void)
{
	//Close all the mutex first
	CloseHandle(mutex);

	bool all_thread = false;
	DWORD  dwExitCode;
	LPDWORD pDwExitCode = &dwExitCode;

	// Killing the expiry thread
	// Get the exit code of the thread
	GetExitCodeThread(expiry_timer, pDwExitCode);
	// Terminate the process
	if (TerminateThread(expiry_timer, dwExitCode))
	{
		std::cout << "The Expiry Timer thread terminated successfully" << std::endl;
		// Close thread handles. 
		CloseHandle(expiry_timer);
		all_thread = true;
	}
	else
	{
		std::cout << "Could not kill the expiry timer thread with error code: " << GetLastError() << std::endl;
		all_thread = false;
	}

	return all_thread;
}


unsigned int __stdcall expire_thread(void* timer_obj)
{
	Timer *timer_properties = (Timer*)timer_obj;

	// Convert milliseconds to seconds
	DWORD sleep_time = 1000 * (DWORD)timer_properties->expiry_time;

	
	Sleep(sleep_time);
	
	// Raise the expiry timer
	WaitForSingleObject(timer_properties->mutex, INFINITE);
	timer_properties->terminate_timer_flag = 1;
	ReleaseMutex(timer_properties->mutex);

	return 0;
}
