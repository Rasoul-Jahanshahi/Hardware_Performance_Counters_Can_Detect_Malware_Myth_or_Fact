# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""

import pyautogui, time, os, logging, subprocess, random, sys, json, signal, psutil
from threading import Thread


class windows_monkey_tester:
    def __init__(self, testing_program, run_time):

        # take a snapshot before running the experiments
        self.process_dict           = {}
        for proc in psutil.pids():
            if proc not in self.process_dict:
                self.process_dict[proc]     = False
        logger.info(self.process_dict)

        kill_thread = Thread(target=self.recover_processes)
        kill_thread.start()

        self.script_folder          = "Y:\\intel_measurements\\amd_benign_scripts\\"
        #self.script_folder          = "C:\\Users\\foo\\Downloads\\monkey\\"
        with open(self.script_folder + "window_info_new.txt", 'r') as data_file:
            window_info = json.load(data_file)
        data_file.close()

        self.program                = window_info[testing_program]['target']
        self.program_window_name    = window_info[testing_program]['window_name']

        self.savitor_path           = self.script_folder + "savitor.exe"
       
        # read events to monitor
        event_list_file             = self.script_folder + "events_to_measure.txt"
        event_list                  = []
        readfile                    = open(event_list_file, 'r')
        for lines in readfile:
            event_list.append(lines.split('\n')[0])
        readfile.close()

        # make a folder to store data
        result_path_dir             = "C:\\Users\\foo\\Desktop\\savitor_experiments"
        clean_directory             = "rmdir " + result_path_dir + " /s /q"
        os.system(clean_directory)
        os.system("mkdir " + result_path_dir)
        os.system("copy " + self.savitor_path + " " + result_path_dir)
        self.savitor_path = result_path_dir + "\\savitor.exe"
       
        # result path
        result_path                 = result_path_dir + "\\run_" + str(run_time) + "_" + \
                                        str(testing_program) + ".txt"
        self.result_path            = result_path
        logger.info(result_path)
        # run program
        my_command      = self.savitor_path + " -e \"" + ' '.join(event_list) + "\"" \
                                            + " -t 60 -f 1000" \
                                            + " -o \"" + result_path + "\"" \
                                            + " -l \"" + self.program + "\""
        
        logger.debug(my_command)
        os.system("echo \"" + my_command + "\" > " + result_path_dir + "\\command.log")
        # if self.program_window_name == "":
        #     sys.exit()
        # else:
        #     self.proc       = subprocess.Popen(my_command, shell=True)
        os.system("cd C:\\Users\\foo\\Desktop\\savitor_experiments")
        self.proc       = subprocess.Popen(my_command, shell=True)

    def recover_processes(self):
        time.sleep(80)
        # compare the snapshot before running the experiments
        for proc in psutil.pids():
            if proc not in self.process_dict:
                try:
                    logger.info("kill pid " + str(proc))
                    p = psutil.Process(proc)
                    p.kill()
                except:
                    continue
        os.system("copy \"" + self.result_path + "\" Z:\\ ")

        
    def minimize_self(self):
        window_list = pyautogui.getWindows()
        for win in window_list:
            if "cmd.exe" in win or "python.exe" in win:
                pyautogui.getWindow(win).minimize()

    def move_to_center(self, program_window, session_size):
        x1, y1, x2, y2  = program_window.get_position()
        width, height   = session_size
        delta_x         = (width - x2 + x1) / 2
        delta_y         = (height - y2 + y1) / 2
        program_window.move(delta_x, delta_y)
        logger.debug("Location Verification " + str(x1) + " " + str(width - x2))
        
    def random_press_key(self, program_window):
        key_list = ['\t', '\n', '\r', ' ', '!', '"', '#', '$', '%', '&', "'", '(',
        ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_', '`',
        'a', 'b', 'c', 'd', 'e','f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~']
        random_key = random.SystemRandom().choice(key_list)
        logger.debug("Monkey pressed " + random_key)
        pyautogui.press(random_key)
        
    def random_click(self, program_window):
        x1, y1, x2, y2  = program_window.get_position()
        random_x        = random.randint(x1, x2)
        random_y        = random.randint(y1, y2)
        logger.debug("Mouse click " + str(random_x) + " " + str(random_y))
        pyautogui.click(x=random_x, y=random_y)

    def random_scrolling(self, program_window):
        random_distance = random.randint(-100, 100)
        logger.debug("Mouse scrolled " + str(random_distance))
        pyautogui.scroll(random_distance)
            
    def run(self):        
        try:
            failed_attempt = 0
            if self.program_window_name != "":
                while pyautogui.getWindow(self.program_window_name) == None and \
                        failed_attempt < 5:
                    logger.info(pyautogui.getWindow(self.program_window_name))
                    time.sleep(1)
                    failed_attempt += 1
                # if there are too many failed attempts, we will send a kill signal
                if failed_attempt < 5:
                    # if it has a window for monkey to play with
                    self.minimize_self()
                    target_window = pyautogui.getWindow(self.program_window_name)
                    self.move_to_center(target_window, pyautogui.size())
                    for _ in range(20):
                        time.sleep(1)
                        self.random_press_key(target_window)
                        self.random_click(target_window)                
                        self.random_scrolling(target_window)

            self.proc.wait()
                
            # kill process after program finishes
            logger.info(self.result_path)
            # close all the windows
            os.system("copy \"" + self.result_path + "\" Z:\\ ")
        except KeyboardInterrupt:
            print '\n Done.'
    
if __name__ == "__main__":
    # logging environent
    logger  = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    
    logger_handler = logging.StreamHandler()
    logger_handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(filename)s [%(lineno)d]: %(funcName)s(): %(message)s'))
    logger.addHandler(logger_handler)
    
    test_program    = sys.argv[1]
    run_time        = sys.argv[2]
    monkey1 = windows_monkey_tester(test_program, run_time)
    monkey1.run()
