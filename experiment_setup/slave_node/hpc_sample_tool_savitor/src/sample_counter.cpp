#include "../include/stdafx.h"

sampling_objects *arg_setup;
sampling_objects *current_struct_object;

unsigned int __stdcall sample_counter_thread(void*);
unsigned int __stdcall write_to_file_thread(void*);

Sample_Counters::Sample_Counters(unsigned int *sampling_time, std::string output_file_name, 
	std::string * individual_events,  unsigned int events_to_profile)
{
	// Thread Properties
	security = NULL;
	stack_size = 512000;
	arglist = (void*)1;
	initflag = CREATE_SUSPENDED;
	thrdaddr = 0;

	// Thread affinity
	DWORD_PTR dwThreadAffinityMask = 0x7F; // Core except the profiling core
	DWORD_PTR thread_affinity = 10; // Randomly choose anything but 0

	// Mutex properties
	lpMutexAttributes = 0;
	bInitialOwner = 0;
	lpName = (LPCTSTR)"sample_counter_mutex";

	// Initialize the variables requred for sampling
	sampling_frequency = *sampling_time;
	event_count = events_to_profile;
	events = new std::string[event_count];
	events = individual_events;
	file.open(output_file_name, std::ios::out | std::ios::trunc);
}

void Sample_Counters::setup_sample_counter(profile *profile_obj )
{

	// Creating the Mutex
	mutex = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);


	// Initialise the objects with the required profiler and the current
	// sampling class
	arg_setup = new sampling_objects;
	arg_setup->current_profiler = profile_obj;
	arg_setup->current_sampler	= this;

	// Setup the arguments for the thread
	arglist = (void*)arg_setup;

	
	// Thread that will periodically sample the HPCs
	_sample_counter = (HANDLE)_beginthreadex(security, stack_size, &sample_counter_thread, 
		arglist, initflag, thrdaddr);
	//Setting the thread's Affintiy
	if (!SetThreadAffinityMask(_sample_counter, dwThreadAffinityMask))
		std::cout << "Could not set the sample thread affinity with error code" << GetLastError() << std::endl;
	// Increase the thread's Priority Class
	if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
		std::cout << "Failed to end upgrade the thread's Priority class: " << GetLastError() << std::endl;
	// Setting up the highest priority
	if (!SetThreadPriority(_sample_counter, THREAD_PRIORITY_TIME_CRITICAL))
		std::cout << "Failed to allot highest priority mode with error code: " << GetLastError();
	
	// Thread to write the sampled values in a file
	_write_to_file = (HANDLE)_beginthreadex(security, stack_size, &write_to_file_thread, 
		arglist, initflag, thrdaddr);
	thread_affinity = SetThreadAffinityMask(_sample_counter, dwThreadAffinityMask);
	if (thread_affinity == 0)
		std::cout << "Could not set the thread for wrinting to a file affinity with error code" 
			 << GetLastError() << std::endl;
	// Setting up the highest priority
	if (!SetThreadPriority(_write_to_file, THREAD_PRIORITY_NORMAL))
		std::cout << "failed to allot highest priority mode with error code: " << GetLastError();
	return;
}

bool Sample_Counters::release_sample_counter_thread(void)
{

	// Variables required to kill all the threads
	bool ret = true;
	DWORD  dwExitCode;
	LPDWORD pDwExitCode = &dwExitCode;

	// Killing the thread that samples the HPCs
	// Get the exit code of the process
	GetExitCodeThread(_sample_counter, pDwExitCode);
	// Terminate the process
	if (TerminateThread(_sample_counter, dwExitCode))
	{
		std::cout << "The sample counter thread terminated successfully" << std::endl;
		// Close process and thread handles. 
		CloseHandle(_sample_counter);
	}
	else
	{
		std::cout << "Could not kill the sample counter thread with error code: " << GetLastError() 
				  << std::endl;
		ret = false;
	}

	return ret;
}

bool Sample_Counters::release_write_file_thread(void)
{
	
	// Variables required to kill all the threads
	bool ret = true;
	DWORD  dwExitCode;
	LPDWORD pDwExitCode = &dwExitCode;

	// Closing the file
	file.close();

	// Killing the thread that write the samples to a thread
	// Get the exit code of the process
	GetExitCodeThread(_write_to_file, pDwExitCode);

	while (1)
	{
		// Wait for all the write operation to finish
		if (sample_queue.empty())
		{
			// Terminate the process
			if (TerminateThread(_write_to_file, dwExitCode))
			{
				std::cout << "The thread writing to a file terminated successfully" << std::endl;
				// Close process and thread handles. 
				CloseHandle(_write_to_file);
			}
			else
			{
				std::cout << "Could not kill the thread writing to a file with error code: " 
						  << GetLastError() << std::endl;
				ret = false;
			}

			break;
		}

	}
	return ret;
}


unsigned int __stdcall sample_counter_thread(void* structs_with_objects)
{
	
	// Create a object that has all the objects required for sampling the hardware performance counters
	current_struct_object = (sampling_objects*)structs_with_objects;

	// Temporary memory region to store all the counter values
	unsigned __int64 *counter_values;
	counter_values = new unsigned __int64[current_struct_object->current_sampler->event_count];
	
	// Tweaking the sampling time to achieve results as close to the sampling frequency requeted by the user
	double sampling_freq = (double) current_struct_object->current_sampler->sampling_frequency;
	
	/* Accounting the overhead taken to sample the HPCs
	 The overhead in the below sample is assumed to be 825us. 
	 This time is determined by measuring the time it takes to read the HPCs using the AMD Code Analyst
	 API. If the thread is not preempted during execution, the time to sample is usually less a 100us.
	 In case the thread is preemepted by the OS scheduler, then it usually takes around 40-60ms to read 
	 the HPCs. We sample the HPCs mutiple times (10000 times) and average out the time it takes the thread to
	 sample 6 events on AMD's Bulldozer architecture. Note: The value (error_ correction_constant) is 
	 determined once as a part of post-processing the data.
	 */
	const double error_correction_constant = 809.5;
	double sampling_time = sampling_freq - error_correction_constant;
	
	// Variables to measure the time taken to measure the HPCs
	std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();
	std::chrono::high_resolution_clock::time_point stop = std::chrono::high_resolution_clock::now();
	__int64 diff = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();

	// Sampling in an infinte loop, where period is controlled by time taken to sample each time the HPCs
	// are read.
	while (1)
	{
		// Log current time for measuring the time it takes to sample the HPCs
		start = std::chrono::high_resolution_clock::now();

		// Perform sampling
		counter_values = current_struct_object->current_profiler->sample_profile(current_struct_object->
			current_sampler->event_count);

		// Push the sampled values to the queue
		// First push the time when the samples where read
		// Subsequently push the samples
		WaitForSingleObject(current_struct_object->current_sampler->mutex, INFINITE);
		
		// Time of sample
		current_struct_object->current_sampler->sample_queue.push(std::chrono::duration_cast
			<std::chrono::microseconds>(start.time_since_epoch()).count());

		// Samples collected from the HPCs
		for (unsigned int i = 0; i < current_struct_object->current_sampler->event_count; i++)
			current_struct_object->current_sampler->sample_queue.push(counter_values[i]);
		ReleaseMutex(current_struct_object->current_sampler->mutex);

		// Stop the timer calculate the diffwence
		// aka the time taken by the current loop to sample
		stop = std::chrono::high_resolution_clock::now();
		diff = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();
		
		// If the time taken to sample is less than the sampling frequency then sleep
		if (diff > 0 && diff < (sampling_time))
			std::this_thread::sleep_for(std::chrono::microseconds((DWORD)(sampling_time-diff)));
	}
	return 0;
}


unsigned int __stdcall write_to_file_thread(void* structs_with_objects)
{
	// Create a object that has all the objects required for writing the smples from the HPCs
	// to a file
	current_struct_object = (sampling_objects*)structs_with_objects;

	// Temporary hold the sampling time of each samples (time since epoch)
	unsigned long long sampling_instant;

	// Keep checking the queue for available samples
	while (1)
	{
		// If queue not empty pop the samples in the queue and write to a file
		if (!current_struct_object->current_sampler->sample_queue.empty())
		{
			WaitForSingleObject(current_struct_object->current_sampler->mutex, INFINITE);
			sampling_instant = current_struct_object->current_sampler->sample_queue.front();
			current_struct_object->current_sampler->sample_queue.pop();
			for (unsigned int i = 0; i < current_struct_object->current_sampler->event_count; i++)
			{
				current_struct_object->current_sampler->file << sampling_instant << ":" 
					<< current_struct_object->current_sampler->events[i] <<":"
					<< current_struct_object->current_sampler->sample_queue.front() << std::endl;
				current_struct_object->current_sampler->sample_queue.pop();
			}
			ReleaseMutex(current_struct_object->current_sampler->mutex);
		}
		
	}
	return 0;
}