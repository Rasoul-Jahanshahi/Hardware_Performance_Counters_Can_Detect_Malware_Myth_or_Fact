#from learn_boyou_all import *
import learn_all_boyou 
import logging, os, sys, json, random
from sklearn.model_selection import train_test_split
import numpy as np

class awesome_learn(learn_all_boyou.boyou_learn):
    def load(self):
        self.benign_data    = {}
        self.malware_data   = {}
        self.report = {}

        benign_files = ['amd_benign_metadata/benign_post_pca_data.txt',\
                        'amd_desktop_metadata/benign_post_pca_data.txt',\
                        'amd_python_benign_metadata/python_benign_post_pca_data.txt'
                        ]
        malware_files = ['amd_malware_metadata/malware_post_pca_data.txt']
        
        for files in benign_files:
            self.logger.info("Loading " + self.data_path_prefix + files + " ... ")
            with open(self.data_path_prefix + files, 'r') as data_file:
                json_data = json.load(data_file)

            for bm in json_data.keys():
                if bm not in self.benign_dict:
                    self.logger.info("benign bm " + bm)
                    self.benign_dict[bm]        = False
                    self.benign_data[bm]        = []
                
                for each_sample in json_data[bm]:
                    if self.benign_data[bm] == []:
                        self.benign_data[bm] = np.array(each_sample) 
                    else:
                        self.benign_data[bm] = np.vstack((self.benign_data[bm], each_sample))

            self.logger.info("benign bm numbers " + str(len(self.benign_dict.keys())))

            data_file.close() 

        for files in malware_files:
            self.logger.info("Loading " + self.data_path_prefix + files + " ... ")
            with open(self.data_path_prefix + files, 'r') as data_file:
                json_data = json.load(data_file)

            for bm in json_data.keys():
                self.malware_dict[bm]       = False
                self.malware_data[bm]       = False
                for each_sample in json_data[bm]:
                    if type(self.malware_data[bm]) is bool:
                        self.malware_data[bm] = np.array(each_sample) 
                    else:
                        self.malware_data[bm] = np.vstack((self.malware_data[bm], each_sample))

            data_file.close() 

        self.sample_size    = min(len(self.benign_data.keys()), \
                                  len(self.malware_data.keys()))
        self.logger.info("benign bm numbers "  + str(len(self.benign_dict.keys())))
        self.logger.info("malware bm numbers " + str(len(self.malware_dict.keys())))
        self.logger.info("Chosen Size " + str(self.sample_size))
        
        # match the number of program samples
        selected_benign_samples = random.sample(self.benign_data.keys(), self.sample_size)
        for bm in self.benign_data.keys():
            if bm not in selected_benign_samples:
                del self.benign_data[bm]
            
        selected_malware_samples = random.sample(self.malware_data.keys(), self.sample_size)
        for bm in self.malware_data.keys():
            if bm not in selected_malware_samples:
                del self.malware_data[bm]

        for bm in self.benign_data:
            self.benign_data[bm] = self.benign_data[bm].tolist()
        for bm in self.malware_data:
            self.malware_data[bm] = self.malware_data[bm].tolist()

        with open(self.result_path + 'benign_data.txt', 'w') as outfile:
            json.dump(self.benign_data, outfile, indent=2)
        outfile.close()

        with open(self.result_path + 'malware_data.txt', 'w') as outfile:
            json.dump(self.malware_data, outfile, indent=2)
        outfile.close()

    def split(self):

        with open(self.result_path + 'benign_data.txt', 'r') as outfile:
            self.benign_data = json.load(outfile)
        outfile.close()

        with open(self.result_path + 'malware_data.txt', 'r') as outfile:
            self.malware_data = json.load(outfile)
        outfile.close()

        self.X_train    = []
        self.X_test     = []
        self.y_train    = []
        self.y_test     = []
        
        def split_and_stack(data, X_train, y_train, \
                                X_test, y_test, type='benign'):
            for bm in data:
                if type == 'benign':
                    labels = np.ones(len(data[bm]))
                else:
                    labels = np.zeros(len(data[bm]))
                        
                single_X_train, single_X_test, single_y_train, single_y_test = \
                    train_test_split(\
                            data[bm], labels, test_size = 0.1, \
                            random_state = random.randint(0, 2**32 -1 ))
                if len(X_train) == 0:
                    X_train = np.array(single_X_train)
                    y_train = np.array(single_y_train)
                    X_test  = np.array(single_X_test)
                    y_test  = np.array(single_y_test)
                else:
                    X_train = np.vstack((X_train, single_X_train))
                    y_train = np.concatenate((y_train, single_y_train))
                    X_test  = np.vstack((X_test, single_X_test))
                    y_test  = np.concatenate((y_test, single_y_test))
            return X_train, y_train, X_test, y_test

        self.X_train, self.y_train, self.X_test, self.y_test = \
            split_and_stack(self.benign_data, self.X_train, self.y_train,\
                                        self.X_test, self.y_test, type='benign')
        self.X_train, self.y_train, self.X_test, self.y_test = \
            split_and_stack(self.malware_data, self.X_train, self.y_train,\
                                        self.X_test, self.y_test, type='malware')
    def run(self):
        self.logger.info('Start to run ...')
        if not os.path.isfile(self.result_path + 'benign_data.txt') or\
            not os.path.isfile(self.result_path + 'malware_data.txt'):
            self.load()
        self.split()
        self.setup_classifiers()
        self.report     = {}
        for names, clf in zip(self.names, self.classifiers):
            self.logger.info(names + " in process ....")
            # train
            clf.fit(self.X_train, self.y_train)
            # if names == 'Decision Tree':
            #     tree.export_graphviz(clf, out_file=self.result_path + 'tree.dot')
            # test

            self.prediction  = clf.predict(self.X_test)
            self.text_class_report(names)

            self.predict_proba  = clf.predict_proba(self.X_test)
            self.roc_curve_report(names)

            self.logger.info(names + " testing completed!")

if __name__ == "__main__":
    
    logger  = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    logger_handler = logging.StreamHandler()
    logger_handler.setFormatter(\
        logging.Formatter('%(asctime)s [%(levelname)s]\
            %(filename)s [%(lineno)d]: %(funcName)s(): %(message)s'))
    logger.addHandler(logger_handler)

    learn1 = awesome_learn(logger, \
            data_path_prefix='../amd_data/')
            #data_path_prefix='/home/bobzhou/2017_summer/data_analysis/amd_data_analysis/')

    learn1.result_path = sys.argv[1] + '/'
    logger.info("files will be saved in the following path: " + learn1.result_path)

    learn1.run()
    #learn1.classic_cross_validation()
    #learn1.test_rasoul()
