// Savitor.cpp : Defines the entry point for the console application.

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/* 
This application will create a time series of events sampled on the HPCs on AMD based machines.
The samples, coupled with the time of sampling are logged into the file as specified by the user.
This application is based on the AMD CodeAnalyst API.

Must Requirements:
1. The application will not work on any other machines other than AMD machines.

Literature Survey:
1. The application is developed using the AMD CodeAnalyst APIs. Please refer to the help manual of the 
   AMD CodeAnalyst software to understand the exact usage of the APIs.
2. BIOS and Kernel Developer's Guide (BKDG) for AMD family XX. 
3. CodeAnalyst User's Manual - AMD Developer Central


Specifications:

1. The application to be profiled is pinned to core 0
2. Sampling the HPCs and writing the samples to the HPCs are taken care by different threads running on 
   cores, other than core 0
3. The samples read from the HPCs are pushed to a sample queue together with the time of samples.
   This enables parallel reading samples from the HPCs and writing the collected samples to a file.

The application is still under development and under maintance. Please contact the author for any queries.

Author:
Anmol Gupta
Integerated Circuits and Signals Groups
MS-CE
Boston University

*/
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/* The application requires the following set of arguments:

-e List of events to sample on the HPCs. 
   Monitor events up to the number of counters available on each core.
   Refer to the AMD's BIOS and Kernel Developers manual to determine the number of counters on your
   AMD machine.
   You could also use the above mentioned document to select the events to monitor.

-f Sampling Frequency -- sampling time in microseconds
   If a project demands to sample 1000 samples per second - usage: -f 1000
   Number of samples can have an error rate of +- 10% i.e. 900 < Sampling Frequency < 1100 Hz. 
   Please contact the author to enquire for faster sampling rates. 
   This application can sample upto 3000 Hz on the AMD Bulldozer architecture

-t Time to run the profiler in seconds

-o Output filename and path
   The output is logged in the following format:
   < Time in microseconds since epoch > : < Event Code > : < Sample Value > 

-l The application to run,  together with its input parameter
   Provide the complete path to the executable and the name of the executable and the necessary
   input arguments to the application
*/
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "../include/stdafx.h"

int main(int argc, char *argv[])
{
	// Temporary hold the input parameters
	std::string arg;

	// Variables related to sampling frequency and execution time of the application to profile
	unsigned int *sampling_time_in_microseconds = new unsigned int[1];
	unsigned int *expiry_time_in_seconds = new unsigned int[1];

	// Variables related to output filename and its path
	std::string output_filename;
	char *application_to_profile;

	// Event related variables
	std::string events; //store the events as std::string. 
	unsigned int *EventSelect; // Array of event selects from the entered events to monitor
	unsigned int *UnitMask; // Array of all the event masks from the entered events to monitor
	unsigned int event_count = 0; //stores the number of events to monitor
	unsigned int event_number = 0; // will store the event number that is being processed 


	for (int i = 1; i < argc; ++i) {
		arg = argv[i];
		if (arg == "-h") {
			show_usage();
			exit(EXIT_SUCCESS);
		}
		else if (arg == "-e") {
			if (i + 1 < argc) { // Make sure we aren't at the end of argv!
				events = argv[++i];
				events += ' ';
			}
			else { // Uh-oh, there was no argument to the destination option.
				std::cerr << "Please provide one or more events. \n Use -h for more info." << std::endl;
				exit(EXIT_FAILURE);
			}
		}
		else if (arg == "-f") {
			if (i + 1 < argc) { // Make sure we aren't at the end of argv!
				*sampling_time_in_microseconds = (unsigned int)atoi(argv[++i]);
			}
			else { // Uh-oh, there was no argument to the destination option.
				std::cerr << "Please provide the sampling freq. \n Use -h for more info." << std::endl;
				exit(EXIT_FAILURE);
			}
		}
		else if (arg == "-t") {
			if (i + 1 < argc) { // Make sure we aren't at the end of argv!
				*expiry_time_in_seconds = (unsigned int)atoi(argv[++i]);
			}
			else { // Uh-oh, there was no argument to the destination option.
				std::cerr << "Please provide the total sampling time. \n Use -h for more info." << std::endl;
				exit(EXIT_FAILURE);
			}
		}
		else if (arg == "-o") {
			if (i + 1 < argc) { // Make sure we aren't at the end of argv!
				output_filename = argv[++i];
				output_filename += '\0';
			}
			else { // Uh-oh, there was no argument to the destination option.
				std::cerr << "Please provide path and the name of the file. \n Use -h for more info."
					<< std::endl;
				exit(EXIT_FAILURE);
			}
		}
		else if (arg == "-l") {
			if (i + 1 < argc) { // Make sure we aren't at the end of argv!
				argv[i+1] += '\0';
				std::string temp_arg = argv[i + 1];
				size_t arg_length = temp_arg.length() + 3;
				application_to_profile = new char[arg_length];
				application_to_profile[0] = '\0';
				strncpy(application_to_profile, "/C \0", (size_t)3);
				strncpy(&application_to_profile[3], argv[++i], arg_length);
			}
			else { // Uh-oh, there was no argument to the destination option.
				std::cerr << "Please provide path and the name of the "
					      << "Application to profile. Use -h for more info."
					<< std::endl;
				exit(EXIT_FAILURE);
			}
		}
		else {
			std::cerr << "Invalid Input: " << arg << std::endl;
			show_usage();
			exit(EXIT_FAILURE);
		}
	}
	
	// Counting the number of events provided by the user 
	for (unsigned int i = 0; i < events.length(); i++) 
	{
		if (events[i] == ' ')
			event_count += 1;
	}

	// Create the profiler object
	// This object will be used to setup the profiler
	profile *sampling = new profile(event_count);

	// Parsing the events and making them. 
	// Refer to AMD CodeAnalyst documentation to understand this process better
	EventSelect = new unsigned int[event_count]; 
	UnitMask = new unsigned int[event_count];
	std::string *individual_event = new std::string[event_count];
	
	for (unsigned int i = 0; i < events.length(); i++)
	{
		if (events[i] != ' ')
			individual_event[event_number] += events[i];
		else
		{
			std::istringstream(individual_event[event_number].substr(2, 3)) >> std::hex >> EventSelect[event_number];
			std::istringstream(individual_event[event_number].substr(5, 2)) >> std::hex >> UnitMask[event_number];
			sampling->make_event(*EventSelect, *UnitMask, event_number++);
		}
	} 
	
	// Initialize the profile
	sampling->init_profile();

	// Confiugre the event
	sampling->config_events(event_count);

	// Setup a new process that executes the application to profile
	RunApp *run_app = new RunApp();
	if (!run_app->setup_RunApp(application_to_profile, sampling->CpuCoreMask))
	{
		while (1);
		exit(EXIT_FAILURE);
	}
	else
	{
		// Start Profiling 
		unsigned int *pProcessId = (unsigned int*)&run_app->lpProcessInformation->dwProcessId;
		sampling->start_profile(pProcessId);
	}


	// Setup the timer thread
	Timer *sampling_time = new Timer(expiry_time_in_seconds);
	sampling_time->setup_timer();

	// Setup the sampler
	Sample_Counters *sampler = new Sample_Counters(sampling_time_in_microseconds, output_filename,
		individual_event, event_count );

	// Setup the sampler thread
	sampler->setup_sample_counter(sampling);
	
	// Enble pausing and resuming the profile
	Pause_Resume *pause_resume_obj = new Pause_Resume();
	pause_resume_obj->setup_pause_resume(sampling);

	
	// Resume the process and the sampling
	DWORD thread_resume_log;
	thread_resume_log = ResumeThread(run_app->lpProcessInformation->hThread);
	if (thread_resume_log == -1)
		std::cout << "Could not resume the process " << GetLastError() << std::endl;
	thread_resume_log = ResumeThread(sampler->_sample_counter);
	if (thread_resume_log == -1)
		std::cout << "Could not resume the sampling counter thread " << GetLastError() << std::endl;
	thread_resume_log = ResumeThread(sampler->_write_to_file);
	if (thread_resume_log == -1)
		std::cout << "Could not resume the thread that writes to a file" << GetLastError() << std::endl;
	thread_resume_log = ResumeThread(sampling_time->expiry_timer);
	if (thread_resume_log == -1)
		std::cout << "Could not resume the expiry timer thread " << GetLastError() << std::endl;
	thread_resume_log = ResumeThread(pause_resume_obj->user_req);
	if (thread_resume_log == -1)
		std::cout << "Could not resume the user request thread " << GetLastError() << std::endl;
	
	// Release the timer, pause and reusme handles and all the mutex
	WaitForSingleObject(sampling_time->expiry_timer, INFINITE);
	
	// Wait for sampling threads are not locked in a mutex
	WaitForSingleObject(sampler->mutex, INFINITE);
	sampling_time->release_timer();
	sampler->release_sample_counter_thread();
	sampler->release_write_file_thread();
	
	// Release the mutex controlling the queue operation
	ReleaseMutex(sampler->mutex);
	
	// Closing the sampler mutex
	CloseHandle(sampler->mutex);

	// Terminating the pasuse and Resume thread
	pause_resume_obj->release_pause_resume();
	
	// Terminating the application being profiled
	run_app->exit_RunApp();
	
	// Stop Profiling
	sampling->end_profile();


	// Free up heap memory
	delete sampling_time_in_microseconds;
	delete expiry_time_in_seconds;
	delete[] EventSelect;
	delete[] UnitMask;
	//delete application_to_profile;
	delete[] sampling;
	delete[] run_app;
	delete[] sampling_time;
	delete sampler;
	delete[] pause_resume_obj;

	// Close application
	exit(EXIT_SUCCESS);
}