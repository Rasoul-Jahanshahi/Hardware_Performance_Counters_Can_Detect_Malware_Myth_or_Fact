import sys, os, json, logging, random
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt
#from matplotlib import gridspec
import numpy as np
import plot_pca_demo

class aggregate_data(plot_pca_demo.pca_demo):
    def load(self):
        with open(self.data_path_prefix + 'amd_metadata/pca_eigenvalues.txt', 'r') as data_file:
            pca_eigen_values    = json.load(data_file)
        data_file.close()
         
        with open(self.data_path_prefix + 'amd_metadata/pca_eigenvector.txt', 'r') as data_file:
            pca_eigenvector     = json.load(data_file)
        data_file.close()
         
        self.logger.info("Loading benignware")
        with open(self.data_path_prefix + 'amd_benign_metadata/pca_data_dict.txt', 'r') as data_file:
            raw_benignware      = json.load(data_file)
        data_file.close()
         
        data_base   = {}
        #selected_benignware = random.choice(raw_benignware.keys())
        selected_benignware = 'creative1'
        # selected_benignware = 'office1'
        selected_experiment =\
        random.sample(raw_benignware[selected_benignware].keys(), 32)
        # selected_event      = '0x02904'
        selected_event      = '0x02B00'

        self.selected_benignware = selected_benignware 
        self.selected_event      = selected_event      
        
        def generate_display(raw_data, testbench_name):
            display = []
            for experiment_number in raw_data[testbench_name]:
                if experiment_number in selected_experiment:
                    if display == []:
                        display = \
                            np.array(raw_data[testbench_name][experiment_number][selected_event])
                    else:
                        display = np.vstack((\
                                display,\
                                np.array(raw_data[testbench_name][experiment_number][selected_event])\
                                ))
            return display

        self.display_benignware  = generate_display(raw_benignware,  selected_benignware)

        def pca_display(raw_data, testbench_name):
            display = []
            for experiment_number in raw_data[testbench_name]:
                if experiment_number in selected_experiment:
                    if display == []:
                        display = np.dot(\
                            np.array(raw_data[testbench_name][experiment_number][selected_event]),\
                            -1 * np.transpose(np.array(pca_eigenvector[selected_event]))\
                        )[0:2]
                    else:
                        display = np.vstack((\
                                display,\
                                np.dot(\
                                    np.array(raw_data[testbench_name][experiment_number][selected_event]),\
                                    -1 * np.transpose(np.array(pca_eigenvector[selected_event]))\
                                    )[0:2]
                                ))
            return display

        self.display_pca_benignware = pca_display(raw_benignware,  selected_benignware)

    def read_raw_data(self):
        self.raw_time = []
        self.raw_data = []
        file_number = str(random.randint(0,6))
        readfile = open('../amd_data/amd_benign_metadata/run__creative_1_results_' + file_number + '.txt', 'r')
        for lines in readfile:
            sample_time     = float(lines.split(':')[0])
            event_name      = lines.split(':')[1]
            sample_numbers  = int(lines.split(':')[2])
            if event_name == self.selected_event:
                self.raw_time.append(sample_time)
                self.raw_data.append(sample_numbers)
       
        max_time = max(self.raw_time) 
        min_time = min(self.raw_time) 
        for idx, single_data in enumerate(self.raw_time):
            self.raw_time[idx] = (32.0 - 1.0) / (max_time - min_time) * (single_data - min_time)
        readfile.close()
        pass

    def plot(self):
        
        
        fig, ax1 = plt.subplots(figsize=(32, 3))
        
        ax1.bar(\
            1 + np.arange(32),\
            np.sum(self.display_benignware, axis=0),\
            yerr=3 * np.std(self.display_benignware, axis=0),\
            capsize=7,\
            ecolor='black',\
            error_kw={'capthick':8},\
            width=0.65,\
            color='#91bfdb')

        ax2 = ax1.twinx()
        ax2.plot(self.raw_time, self.raw_data, linewidth=3, color='red')
        ax1.set_ylabel('Number of Samples \nin Aggregate Data')
        ax1.set_xlabel('Histogram Bin Numbers')
        ax2.set_ylabel('Number of Samples \nin Raw Results')

        savefig_name = PdfPages(self.result_path + 'aggregate_data.pdf')
        plt.savefig(savefig_name, format='pdf', bbox_inches='tight')
        savefig_name.close()
        plt.close()

    def run(self):
        self.load()
        self.read_raw_data()
        self.plot()
    

if __name__ == "__main__":
    
    font = {\
            'family' : 'serif',\
            'size'   : 30}
    plt.rc('font', **font)

    logger  = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    logger_handler = logging.StreamHandler()
    logger_handler.setFormatter(\
        logging.Formatter('%(asctime)s [%(levelname)s]\
            %(filename)s [%(lineno)d]: %(funcName)s(): %(message)s'))
    logger.addHandler(logger_handler)

    aggregate1 = aggregate_data(logger, \
            data_path_prefix='../amd_data/')
            #data_path_prefix='/home/bobzhou/2017_summer/data_analysis/amd_data_analysis/')
    aggregate1.result_path = 'figures/'
    aggregate1.run()
