#include "../include/stdafx.h"

// Thread body
unsigned int __stdcall pause_thread(void*);
unsigned int __stdcall resume_thread(void*);
unsigned int __stdcall user_request_thread(void*);

Pause_Resume::Pause_Resume()
{
	// Thread Properties
	security = NULL;
	stack_size = 512000;
	arglist = (void*)1;
	arglist_ui = (void*)1;
	initflag = CREATE_SUSPENDED;
	thrdaddr = 0;

	// Thread Affinity
	DWORD_PTR dwThreadAffinityMask = 0x010; // Core 2
	DWORD_PTR thread_affinity = 10; // Randomly choose anything but 0

	// Mutex properties
	lpMutexAttributes = 0;
	bInitialOwner = 0;
	lpName = (LPCTSTR)"mutex";

	// Variables that require atomicity
	user_in = ' ';

}

void Pause_Resume::setup_pause_resume(profile *current_profile)
{

	// Use the funciton argument to pass the profiler object
	arglist = (void*)current_profile;

	// Use the current object to get the user choice
	arglist_ui = (void*)this;

	// Creating the Mutex
	mutex = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);

	// Start a thread to accept the user choice
	user_req = (HANDLE)_beginthreadex(security, stack_size, &user_request_thread, arglist_ui, initflag, thrdaddr);
	// Set the threads affinity
	thread_affinity = SetThreadAffinityMask(user_req, dwThreadAffinityMask);
	if (thread_affinity == 0)
		std::cout << "Could not set the thread affinity with error code" << GetLastError() << std::endl;
	
}

bool Pause_Resume::release_pause_resume(void)
{
	bool all_thread = false;
	DWORD  dwExitCode;
	LPDWORD pDwExitCode = &dwExitCode;

	// Get the exit code of the process
	GetExitCodeThread(user_req, pDwExitCode);
	// Terminate the process
	if (TerminateThread(user_req, dwExitCode))
	{
		std::cout << "The Pause_resume thread terminated successfully" << std::endl;
		// Close process and thread handles. 
		CloseHandle(user_req);
		all_thread = true;
	}
	else
	{
		std::cout << "Could not kill the Pause_resume thread with error code: " << GetLastError() << std::endl;
		all_thread = false;
	}

	// Killing the pause thread
	// Get the exit code of the process
	GetExitCodeThread(pause, pDwExitCode);
	// Terminate the process
	if (TerminateThread(pause, dwExitCode))
	{
		std::cout << "The Pause thread terminated successfully" << std::endl;
		// Close process and thread handles. 
		CloseHandle(pause);
		all_thread = true;
	}
	else
	{
		std::cout << "Could not kill the Pause thread with error code: " << GetLastError() << std::endl;
		all_thread = false;
	}

	// Killing the Resume thread
	// Get the exit code of the process
	GetExitCodeThread(resume, pDwExitCode);
	// Terminate the process
	if (TerminateThread(resume, dwExitCode))
	{
		std::cout << "The Resume thread terminated successfully" << std::endl;
		// Close process and thread handles. 
		CloseHandle(resume);
		all_thread = true;
	}
	else
	{
		std::cout << "Could not kill the Resume thread with error code: " << GetLastError() << std::endl;
		all_thread = false;
	}

	CloseHandle(mutex);
	
	return all_thread;
}

unsigned int __stdcall user_request_thread(void* current_pause_resume)
{
	// Get the object of the current profiler
	Pause_Resume *current = (Pause_Resume*)current_pause_resume;

	// Print the message to accecpt the user input
	std::cout << "Press P for Pausing the profiler." << std::endl;
	std::cout << "Press R for Resuming the profiler." << std::endl;

	// Poll till you get the user input
	while (1)
	{
		// Accept the user input
		WaitForSingleObject(current->mutex, INFINITE);
		current->user_in = getchar();
		ReleaseMutex(current->mutex);

		// Pause Thread
		if (current->user_in == 'P' || current->user_in == 'p')
		{
			WaitForSingleObject(current->mutex, INFINITE);
			// Starts the thread in Run state
			current->initflag = 0;
			// Reset the user input
			current->user_in = ' ';
			// Start a thread to pause the current profiler
			current->pause = (HANDLE)_beginthreadex(current->security, current->stack_size,
				&pause_thread, current->arglist, current->initflag, current->thrdaddr);
			// Set the threads affinity
			current->thread_affinity = SetThreadAffinityMask(current->pause, current->dwThreadAffinityMask);
			if (current->thread_affinity == 0)
				std::cout << "Could not set the thread affinity with error code" << GetLastError() << std::endl;
			WaitForSingleObject(current->pause, INFINITE);
			ReleaseMutex(current->mutex);
		}

		// Resume Thread
		else if (current->user_in == 'R' || current->user_in == 'r')
		{
			// Suspend reading the user input
			WaitForSingleObject(current->mutex, INFINITE);
			// Starts the thread in Run state
			current->initflag = 0;
			//Reset the user input
			WaitForSingleObject(current->mutex, INFINITE);
			current->user_in = ' ';
			// Start a thread to pause the current profiler
			current->resume = (HANDLE)_beginthreadex(current->security, current->stack_size,
				&resume_thread, current->arglist, current->initflag, current->thrdaddr);
			// Set the threads affinity
			current->thread_affinity = SetThreadAffinityMask(current->resume, current->dwThreadAffinityMask);
			if (current->thread_affinity == 0)
				std::cout << "Could not set the thread affinity with error code" << GetLastError() << std::endl;
			WaitForSingleObject(current->resume, INFINITE);
			ReleaseMutex(current->mutex);
		}
		else
		{
			std::cout << "Press P for Pausing the profiler." << std::endl;
			std::cout << "Press R for Resuming the profiler." << std::endl;
			continue;
		}

	}
	
	return 0;
}

unsigned int __stdcall pause_thread(void* profiler)
{

	// Get the profile object that will pause the profiler
	profile *current_profiler = (profile*)profiler;

	// Pause the current profiler 
	current_profiler->error_log = fnPauseProfiling(current_profiler->pause_resume_key);
	if (current_profiler->error_log == S_OK)
	{
		std::cout << "Pausing profile. " 
			 << "Current Profiler state: " << current_profiler->get_profiler_state() 
			 << std::endl;
	}
	else
	{
		std::cout << "Either the profiler already in Paused state or possible error: " 
			 << current_profiler->error_decode(current_profiler->error_log)
		 	 << std::endl;
		return 0;
	}

	return 0;
}

unsigned int __stdcall resume_thread(void* profiler)
{
	profile *current_profiler = (profile*)profiler;

	// Pause the current profiler
	current_profiler->error_log = fnResumeProfiling(current_profiler->pause_resume_key);
	if (current_profiler->error_log == S_OK)
	{
		std::cout << "Resuming profile. "
			<< "Current Profiler state: " << current_profiler->get_profiler_state()
			<< std::endl;
	}
	else
	{
		std::cout << "Either the profiler already in Paused state or possible error: "
			<< current_profiler->error_decode(current_profiler->error_log)
			<< std::endl;
		return 0;
	}

	return 0;
}

